// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: responses.sql

package api

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const attemptResponseIDs = `-- name: AttemptResponseIDs :many
select id from responses where attempt_id = $1
`

func (q *Queries) AttemptResponseIDs(ctx context.Context, attemptID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, attemptResponseIDs, attemptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createResponse = `-- name: CreateResponse :one
insert into responses(quiz_id, user_id, attempt_id, question_id, text) values($1,$2,$3,$4,$5) returning id, created_at, quiz_id, user_id, attempt_id, question_id, text
`

type CreateResponseParams struct {
	QuizID     int64
	UserID     int64
	AttemptID  int64
	QuestionID int64
	Text       string
}

func (q *Queries) CreateResponse(ctx context.Context, arg CreateResponseParams) (Response, error) {
	row := q.db.QueryRow(ctx, createResponse,
		arg.QuizID,
		arg.UserID,
		arg.AttemptID,
		arg.QuestionID,
		arg.Text,
	)
	var i Response
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.QuizID,
		&i.UserID,
		&i.AttemptID,
		&i.QuestionID,
		&i.Text,
	)
	return i, err
}

const responseCount = `-- name: ResponseCount :one
select count(*) from responses where attempt_id = $1
`

func (q *Queries) ResponseCount(ctx context.Context, attemptID int64) (int64, error) {
	row := q.db.QueryRow(ctx, responseCount, attemptID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const responses = `-- name: Responses :many
select
   responses.id, responses.created_at, responses.quiz_id, responses.user_id, responses.attempt_id, responses.question_id, responses.text,
   questions.answer question_answer,
   questions.text question_text,
   questions.answer = responses.text is_correct
from responses
 join questions on responses.question_id = questions.id
 where attempt_id = $1
order by responses.created_at
`

type ResponsesRow struct {
	ID             int64
	CreatedAt      pgtype.Timestamptz
	QuizID         int64
	UserID         int64
	AttemptID      int64
	QuestionID     int64
	Text           string
	QuestionAnswer string
	QuestionText   string
	IsCorrect      bool
}

func (q *Queries) Responses(ctx context.Context, attemptID int64) ([]ResponsesRow, error) {
	rows, err := q.db.Query(ctx, responses, attemptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ResponsesRow
	for rows.Next() {
		var i ResponsesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.QuizID,
			&i.UserID,
			&i.AttemptID,
			&i.QuestionID,
			&i.Text,
			&i.QuestionAnswer,
			&i.QuestionText,
			&i.IsCorrect,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

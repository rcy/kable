// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package api

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"oj/avatar"
	"oj/gradient"
)

const allUsers = `-- name: AllUsers :many
select id, created_at, username, email, avatar_url_deprecated, is_parent, bio, become_user_id, admin, gradient, avatar from users order by created_at desc
`

func (q *Queries) AllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, allUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Username,
			&i.Email,
			&i.AvatarUrlDeprecated,
			&i.IsParent,
			&i.Bio,
			&i.BecomeUserID,
			&i.Admin,
			&i.Gradient,
			&i.Avatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createParent = `-- name: CreateParent :one
insert into users(email, username, is_parent) values($1, $2, true) returning id, created_at, username, email, avatar_url_deprecated, is_parent, bio, become_user_id, admin, gradient, avatar
`

type CreateParentParams struct {
	Email    pgtype.Text
	Username string
}

func (q *Queries) CreateParent(ctx context.Context, arg CreateParentParams) (User, error) {
	row := q.db.QueryRow(ctx, createParent, arg.Email, arg.Username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Username,
		&i.Email,
		&i.AvatarUrlDeprecated,
		&i.IsParent,
		&i.Bio,
		&i.BecomeUserID,
		&i.Admin,
		&i.Gradient,
		&i.Avatar,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
insert into users(username) values($1) returning id, created_at, username, email, avatar_url_deprecated, is_parent, bio, become_user_id, admin, gradient, avatar
`

func (q *Queries) CreateUser(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, createUser, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Username,
		&i.Email,
		&i.AvatarUrlDeprecated,
		&i.IsParent,
		&i.Bio,
		&i.BecomeUserID,
		&i.Admin,
		&i.Gradient,
		&i.Avatar,
	)
	return i, err
}

const getConnection = `-- name: GetConnection :one
select u.id, u.created_at, u.username, u.email, u.avatar_url_deprecated, u.is_parent, u.bio, u.become_user_id, u.admin, u.gradient, u.avatar,
       case
           when f1.a_id = $1 then f1.b_role
           else ''
       end as role_out,
       case
           when f2.b_id = $1 then f2.b_role
           else ''
       end as role_in
from users u
left join friends f1 on f1.b_id = u.id and f1.a_id = $1
left join friends f2 on f2.a_id = u.id and f2.b_id = $1
where
  u.id = $2
`

type GetConnectionParams struct {
	AID int64
	ID  int64
}

type GetConnectionRow struct {
	ID                  int64
	CreatedAt           pgtype.Timestamptz
	Username            string
	Email               pgtype.Text
	AvatarUrlDeprecated string
	IsParent            bool
	Bio                 string
	BecomeUserID        pgtype.Int8
	Admin               bool
	Gradient            gradient.Gradient
	Avatar              avatar.Avatar
	RoleOut             string
	RoleIn              string
}

func (q *Queries) GetConnection(ctx context.Context, arg GetConnectionParams) (GetConnectionRow, error) {
	row := q.db.QueryRow(ctx, getConnection, arg.AID, arg.ID)
	var i GetConnectionRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Username,
		&i.Email,
		&i.AvatarUrlDeprecated,
		&i.IsParent,
		&i.Bio,
		&i.BecomeUserID,
		&i.Admin,
		&i.Gradient,
		&i.Avatar,
		&i.RoleOut,
		&i.RoleIn,
	)
	return i, err
}

const getConnections = `-- name: GetConnections :many
select u.id, u.created_at, u.username, u.email, u.avatar_url_deprecated, u.is_parent, u.bio, u.become_user_id, u.admin, u.gradient, u.avatar from users u
join friends f1 on f1.b_id = u.id and f1.a_id = $1
join friends f2 on f2.a_id = u.id and f2.b_id = $1
where f1.b_role <> '' and f2.b_role <> ''
`

func (q *Queries) GetConnections(ctx context.Context, aID int64) ([]User, error) {
	rows, err := q.db.Query(ctx, getConnections, aID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Username,
			&i.Email,
			&i.AvatarUrlDeprecated,
			&i.IsParent,
			&i.Bio,
			&i.BecomeUserID,
			&i.Admin,
			&i.Gradient,
			&i.Avatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentAndPotentialParentConnections = `-- name: GetCurrentAndPotentialParentConnections :many
select u.id, u.created_at, u.username, u.email, u.avatar_url_deprecated, u.is_parent, u.bio, u.become_user_id, u.admin, u.gradient, u.avatar,
       case
           when f1.a_id = $1 then f1.b_role
           else ''
       end as role_out,
       case
           when f2.b_id = $1 then f2.b_role
           else ''
       end as role_in
from users u
left join friends f1 on f1.b_id = u.id and f1.a_id = $1
left join friends f2 on f2.a_id = u.id and f2.b_id = $1
where
  u.id != $1
and
  is_parent = true
order by role_in desc
limit 128
`

type GetCurrentAndPotentialParentConnectionsRow struct {
	ID                  int64
	CreatedAt           pgtype.Timestamptz
	Username            string
	Email               pgtype.Text
	AvatarUrlDeprecated string
	IsParent            bool
	Bio                 string
	BecomeUserID        pgtype.Int8
	Admin               bool
	Gradient            gradient.Gradient
	Avatar              avatar.Avatar
	RoleOut             string
	RoleIn              string
}

func (q *Queries) GetCurrentAndPotentialParentConnections(ctx context.Context, aID int64) ([]GetCurrentAndPotentialParentConnectionsRow, error) {
	rows, err := q.db.Query(ctx, getCurrentAndPotentialParentConnections, aID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCurrentAndPotentialParentConnectionsRow
	for rows.Next() {
		var i GetCurrentAndPotentialParentConnectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Username,
			&i.Email,
			&i.AvatarUrlDeprecated,
			&i.IsParent,
			&i.Bio,
			&i.BecomeUserID,
			&i.Admin,
			&i.Gradient,
			&i.Avatar,
			&i.RoleOut,
			&i.RoleIn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFamily = `-- name: GetFamily :many
select u.id, u.created_at, u.username, u.email, u.avatar_url_deprecated, u.is_parent, u.bio, u.become_user_id, u.admin, u.gradient, u.avatar
from users u
join friends f1 on f1.b_id = u.id and f1.a_id = $1
join friends f2 on f2.a_id = u.id and f2.b_id = $1
where f1.b_role <> 'friend'
`

func (q *Queries) GetFamily(ctx context.Context, aID int64) ([]User, error) {
	rows, err := q.db.Query(ctx, getFamily, aID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Username,
			&i.Email,
			&i.AvatarUrlDeprecated,
			&i.IsParent,
			&i.Bio,
			&i.BecomeUserID,
			&i.Admin,
			&i.Gradient,
			&i.Avatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriends = `-- name: GetFriends :many
select u.id, u.created_at, u.username, u.email, u.avatar_url_deprecated, u.is_parent, u.bio, u.become_user_id, u.admin, u.gradient, u.avatar from users u
join friends f1 on f1.b_id = u.id and f1.a_id = $1 and f1.b_role = 'friend'
join friends f2 on f2.a_id = u.id and f2.b_id = $1 and f2.b_role = 'friend'
`

func (q *Queries) GetFriends(ctx context.Context, aID int64) ([]User, error) {
	rows, err := q.db.Query(ctx, getFriends, aID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Username,
			&i.Email,
			&i.AvatarUrlDeprecated,
			&i.IsParent,
			&i.Bio,
			&i.BecomeUserID,
			&i.Admin,
			&i.Gradient,
			&i.Avatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKids = `-- name: GetKids :many
select u.id, u.created_at, u.username, u.email, u.avatar_url_deprecated, u.is_parent, u.bio, u.become_user_id, u.admin, u.gradient, u.avatar from users u
join friends f1 on f1.b_id = u.id and f1.a_id = $1 and f1.b_role = 'child'
join friends f2 on f2.a_id = u.id and f2.b_id = $1 and f2.b_role = 'parent'
`

func (q *Queries) GetKids(ctx context.Context, aID int64) ([]User, error) {
	rows, err := q.db.Query(ctx, getKids, aID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Username,
			&i.Email,
			&i.AvatarUrlDeprecated,
			&i.IsParent,
			&i.Bio,
			&i.BecomeUserID,
			&i.Admin,
			&i.Gradient,
			&i.Avatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParents = `-- name: GetParents :many
select u.id, u.created_at, u.username, u.email, u.avatar_url_deprecated, u.is_parent, u.bio, u.become_user_id, u.admin, u.gradient, u.avatar from users u
join friends f1 on f1.b_id = u.id and f1.a_id = $1 and f1.b_role = 'parent'
join friends f2 on f2.a_id = u.id and f2.b_id = $1 and f2.b_role = 'child'
`

func (q *Queries) GetParents(ctx context.Context, aID int64) ([]User, error) {
	rows, err := q.db.Query(ctx, getParents, aID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Username,
			&i.Email,
			&i.AvatarUrlDeprecated,
			&i.IsParent,
			&i.Bio,
			&i.BecomeUserID,
			&i.Admin,
			&i.Gradient,
			&i.Avatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const kidsByParentID = `-- name: KidsByParentID :many
select users.id, users.created_at, users.username, users.email, users.avatar_url_deprecated, users.is_parent, users.bio, users.become_user_id, users.admin, users.gradient, users.avatar from kids_parents join users on kids_parents.kid_id = users.id where kids_parents.parent_id = $1 order by kids_parents.created_at desc
`

func (q *Queries) KidsByParentID(ctx context.Context, parentID int64) ([]User, error) {
	rows, err := q.db.Query(ctx, kidsByParentID, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Username,
			&i.Email,
			&i.AvatarUrlDeprecated,
			&i.IsParent,
			&i.Bio,
			&i.BecomeUserID,
			&i.Admin,
			&i.Gradient,
			&i.Avatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const parentByID = `-- name: ParentByID :one
select id, created_at, username, email, avatar_url_deprecated, is_parent, bio, become_user_id, admin, gradient, avatar from users where id = $1 and is_parent = true
`

func (q *Queries) ParentByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, parentByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Username,
		&i.Email,
		&i.AvatarUrlDeprecated,
		&i.IsParent,
		&i.Bio,
		&i.BecomeUserID,
		&i.Admin,
		&i.Gradient,
		&i.Avatar,
	)
	return i, err
}

const parentsByKidID = `-- name: ParentsByKidID :many
select users.id, users.created_at, users.username, users.email, users.avatar_url_deprecated, users.is_parent, users.bio, users.become_user_id, users.admin, users.gradient, users.avatar from kids_parents join users on kids_parents.parent_id = users.id where kids_parents.kid_id = $1
`

func (q *Queries) ParentsByKidID(ctx context.Context, kidID int64) ([]User, error) {
	rows, err := q.db.Query(ctx, parentsByKidID, kidID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Username,
			&i.Email,
			&i.AvatarUrlDeprecated,
			&i.IsParent,
			&i.Bio,
			&i.BecomeUserID,
			&i.Admin,
			&i.Gradient,
			&i.Avatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserAvatar = `-- name: UpdateUserAvatar :one
update users set avatar = $1 where id = $2 returning id, created_at, username, email, avatar_url_deprecated, is_parent, bio, become_user_id, admin, gradient, avatar
`

type UpdateUserAvatarParams struct {
	Avatar avatar.Avatar
	ID     int64
}

func (q *Queries) UpdateUserAvatar(ctx context.Context, arg UpdateUserAvatarParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserAvatar, arg.Avatar, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Username,
		&i.Email,
		&i.AvatarUrlDeprecated,
		&i.IsParent,
		&i.Bio,
		&i.BecomeUserID,
		&i.Admin,
		&i.Gradient,
		&i.Avatar,
	)
	return i, err
}

const updateUserGradient = `-- name: UpdateUserGradient :one
update users set gradient = $1 where id = $2 returning id, created_at, username, email, avatar_url_deprecated, is_parent, bio, become_user_id, admin, gradient, avatar
`

type UpdateUserGradientParams struct {
	Gradient gradient.Gradient
	UserID   int64
}

func (q *Queries) UpdateUserGradient(ctx context.Context, arg UpdateUserGradientParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserGradient, arg.Gradient, arg.UserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Username,
		&i.Email,
		&i.AvatarUrlDeprecated,
		&i.IsParent,
		&i.Bio,
		&i.BecomeUserID,
		&i.Admin,
		&i.Gradient,
		&i.Avatar,
	)
	return i, err
}

const userByEmail = `-- name: UserByEmail :one
select id, created_at, username, email, avatar_url_deprecated, is_parent, bio, become_user_id, admin, gradient, avatar from users where email = $1
`

func (q *Queries) UserByEmail(ctx context.Context, email pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, userByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Username,
		&i.Email,
		&i.AvatarUrlDeprecated,
		&i.IsParent,
		&i.Bio,
		&i.BecomeUserID,
		&i.Admin,
		&i.Gradient,
		&i.Avatar,
	)
	return i, err
}

const userByID = `-- name: UserByID :one
select id, created_at, username, email, avatar_url_deprecated, is_parent, bio, become_user_id, admin, gradient, avatar from users where id = $1
`

func (q *Queries) UserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, userByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Username,
		&i.Email,
		&i.AvatarUrlDeprecated,
		&i.IsParent,
		&i.Bio,
		&i.BecomeUserID,
		&i.Admin,
		&i.Gradient,
		&i.Avatar,
	)
	return i, err
}

const userBySessionKey = `-- name: UserBySessionKey :one
select users.id, users.created_at, users.username, users.email, users.avatar_url_deprecated, users.is_parent, users.bio, users.become_user_id, users.admin, users.gradient, users.avatar from sessions join users on sessions.user_id = users.id where sessions.key = $1
`

func (q *Queries) UserBySessionKey(ctx context.Context, key string) (User, error) {
	row := q.db.QueryRow(ctx, userBySessionKey, key)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Username,
		&i.Email,
		&i.AvatarUrlDeprecated,
		&i.IsParent,
		&i.Bio,
		&i.BecomeUserID,
		&i.Admin,
		&i.Gradient,
		&i.Avatar,
	)
	return i, err
}

const userByUsername = `-- name: UserByUsername :one
select id, created_at, username, email, avatar_url_deprecated, is_parent, bio, become_user_id, admin, gradient, avatar from users where username = $1
`

func (q *Queries) UserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, userByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Username,
		&i.Email,
		&i.AvatarUrlDeprecated,
		&i.IsParent,
		&i.Bio,
		&i.BecomeUserID,
		&i.Admin,
		&i.Gradient,
		&i.Avatar,
	)
	return i, err
}

const usersWithUnreadCounts = `-- name: UsersWithUnreadCounts :many
select users.id, users.created_at, users.username, users.email, users.avatar_url_deprecated, users.is_parent, users.bio, users.become_user_id, users.admin, users.gradient, users.avatar, count(*) unread_count
from deliveries
join users on sender_id = users.id
where recipient_id = $1 and sent_at is null
group by users.id
`

type UsersWithUnreadCountsRow struct {
	ID                  int64
	CreatedAt           pgtype.Timestamptz
	Username            string
	Email               pgtype.Text
	AvatarUrlDeprecated string
	IsParent            bool
	Bio                 string
	BecomeUserID        pgtype.Int8
	Admin               bool
	Gradient            gradient.Gradient
	Avatar              avatar.Avatar
	UnreadCount         int64
}

func (q *Queries) UsersWithUnreadCounts(ctx context.Context, recipientID int64) ([]UsersWithUnreadCountsRow, error) {
	rows, err := q.db.Query(ctx, usersWithUnreadCounts, recipientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersWithUnreadCountsRow
	for rows.Next() {
		var i UsersWithUnreadCountsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Username,
			&i.Email,
			&i.AvatarUrlDeprecated,
			&i.IsParent,
			&i.Bio,
			&i.BecomeUserID,
			&i.Admin,
			&i.Gradient,
			&i.Avatar,
			&i.UnreadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
